# ¿Qué diferencia a Javascript de cualquier otro lenguaje de programación?

Anteriormente, la interfaz del sitio web constaba de textos, enlaces e ilustraciones, y estaba diseñada utilizando **HTML** y **CSS**.
Todo cambió con la creación de JavaScript. Este lenguaje de programación hizo que los sitios web fueran interactivos, es decir, fáciles de usar. Aparecieron botones, formularios, campos de entrada y mucho más.

**JavaScript** (o **JS** en otras palabras) es un lenguaje de programación multifuncional. JavaScript se utiliza no sólo para crear sitios web, sino también para escribir muchos programas diferentes.

## ¿Dónde se utiliza JavaScript?
### Interfaz de aplicación web

Con JavaScript, los desarrolladores crean aplicaciones web; estos son programas que ejecutamos en el navegador. Estos incluyen clientes de correo electrónico, editores de texto, redes sociales, sitios de alojamiento de vídeos y mucho más.

JavaScript se utiliza para crear la "interfaz externa" de las aplicaciones web: la interfaz. El usuario interactúa con él haciendo clic en botones, mosaicos y menús.

El código de servicios populares como Google Maps, Google Docs, Netflix y eBay está escrito en JavaScript.

### Backend de aplicaciones web

Además de la interfaz que ven los usuarios, las aplicaciones web también tienen una parte interna: un backend. Este es el back-end de la aplicación donde normalmente se almacenan las bases de datos.

JavaScript tiene Node.js: no es un lenguaje de programación independiente, sino un entorno de ejecución del lado del servidor para código JavaScript. Se puede utilizar para realizar operaciones o acceder a bases de datos.

JavaScript junto con Node.js es utilizado por empresas conocidas como PayPal y Walmart para interactuar con sus servidores.

### Extensiones del navegador

Las extensiones del navegador son miniprogramas que constan de código que se ejecuta en el navegador. Las extensiones nos ayudan a bloquear anuncios, habilitar VPN, descargar vídeos o contar el tiempo que pasamos en Internet. Y casi todos están escritos en JavaScript.

### Aplicaciones móviles

Las aplicaciones para iOS y Android también están escritas en JavaScript. Para esto existen marcos especiales: conjuntos de códigos ya preparados, el "marco" de aplicaciones futuras.

Los marcos de JavaScript como React Native lo ayudan a adaptar su código a las plataformas móviles. Esto le permite crear aplicaciones multiplataforma, que se ejecutan tanto en iOS como en Android, sin tener que contratar desarrolladores para cada uno de estos sistemas y crear dos versiones de la aplicación.

Las aplicaciones móviles para Groupon y LinkedIn están escritas en JavaScript.

### Juegos

También puedes escribir juegos simples en JavaScript. Por lo general, se trata de juegos de aventuras basados ​​en navegador, pero a veces también hay proyectos independientes interesantes como “2048”, PixelDefense, BrowserQuest.

También existe Unity3d, un marco de programación de juegos basado en JavaScript que se ejecuta fuera de los navegadores.

### Aprendizaje automático

La mayoría de las veces, el aprendizaje automático utiliza otros lenguajes de programación, como Python. Sin embargo, a veces también se utiliza JavaScript para esto. Por ejemplo, al crear aplicaciones web, incluidas aquellas que visualizan datos de modelos de aprendizaje automático. O al escribir una página web con un formulario que envía datos al servidor para su procesamiento mediante un modelo de aprendizaje automático.

Además, ya se han escrito varias bibliotecas para JavaScript (conjuntos de códigos ya preparados) a partir de las cuales puede crear su propia red neuronal. Estos son, por ejemplo, Brain.js, Deep Playground, Synaptic o FlappyLearning.

### Base de datos

JavaScript tiene su propia herramienta, Mongoose, que permite trabajar con MongoDB. También existen bases de datos, por ejemplo, Clusterpoint, en las que puede escribir consultas en JavaScript.

También existe GraphQL, un lenguaje de consulta estructurado que permite acceder a bases de datos. Funciona con React y otros marcos de JavaScript populares.

### Internet de las Cosas

JavaScript también se utiliza en Internet de las cosas (Internet of Things, IoT): es una forma de intercambiar información entre dispositivos conectados a la misma red. Conocemos ejemplos de este tipo de dispositivos: relojes inteligentes, rastreadores de actividad física, alarmas contra incendios. Los programas están escritos para ellos en JavaScript utilizando los marcos Cylon.js y Johnny-Five.

## Popularidad de JavaScript

JavaScript se encuentra regularmente entre los lenguajes de programación más comunes. Según el índice TIOBE (creado a partir de consultas de búsqueda), JavaScript ocupa el sexto lugar en septiembre de 2023.
Según GitHub, JavaScript, junto con TypeScript, ya controla un tercio del mercado de desarrollo. Recibió un honorable primer lugar en el ranking de idiomas de uso comercial. El 19% de los encuestados lo escribe.

## El futuro de JavaScript

Se escriben enormes cantidades de código en JavaScript. Es casi imposible reescribirlos en poco tiempo y todavía no es necesario. Esto significa que en un futuro próximo habrá una demanda de especialistas que puedan trabajar con JavaScript y dar soporte a los programas que lo utilizan.

Se ha formado un enorme ecosistema de bibliotecas y marcos en torno a JavaScript, como React, Angular y Vue.js. Estas herramientas hacen que el desarrollo sea más eficiente. La posesión de los mismos es un requisito obligatorio que tienen muchas vacantes.

Actualmente se está desarrollando activamente la plataforma Node.js, con la que se pueden escribir aplicaciones de servidor. Por lo tanto, el backend de JavaScript también tendrá demanda.

Actualmente, Google está desarrollando activamente el segmento de aplicaciones web progresivas: una mezcla de un sitio web estándar y una aplicación móvil. Estas soluciones (aplicaciones web progresivas) tienen amplias perspectivas. Son beneficiosos para las empresas, por lo que tienen la posibilidad de participar en un mercado que hasta ahora pertenece a aplicaciones desarrolladas para una sola plataforma.

Todo esto en conjunto hace de JavaScript un lenguaje de programación prometedor que seguirá desempeñando un papel importante en diversos campos: desde el desarrollo web hasta el diseño de juegos.

## ¿Qué significa el script en el nombre JavaScript?

A principios de los 90, cuando se creó JavaScript, Netscape estaba desarrollando un navegador llamado Netscape Navigator. Según lo previsto, el navegador debería tener la capacidad de crear páginas web interactivas y dinámicas.

La empresa contrató al programador Brendan Icke para desarrollar un nuevo lenguaje de programación. Debería haberse llamado LiveScript. Pero debido a la popularidad del lenguaje Java (desarrollado por Sun Microsystems), Netscape decidió cambiar su nombre a JavaScript para llamar la atención y asociarlo con Java.

JavaScript es un lenguaje de programación que se utiliza para escribir scripts. Los scripts son pequeños programas que se ejecutan dentro de un navegador web y añaden interactividad a las páginas web. Por ejemplo, JavaScript se puede utilizar para crear validación de formularios, animaciones, manejo de eventos (como clics del mouse) y mucho más para hacer que las páginas web sean más dinámicas y fáciles de usar.

JavaScript es un lenguaje de programación en el que puedes escribir un script. Este es un pequeño programa que se ejecuta dentro del navegador y agrega interactividad a la página. Gracias a los programas script y JavaScript podemos dar me gusta al contenido que nos gusta, escribir comentarios, compartir publicaciones en redes sociales y mucho más.

## ¿Cuáles son las características de JavaScript?
### Integración con HTML y CSS

HTML es un lenguaje de marcado y CSS es una hoja de estilo. No puede escribir código completo en ellos: solo puede colocar elementos en la página de un sitio web.

Pero ya puedes escribir código en JavaScript y este lenguaje está integrado con lenguajes de marcado. Es decir, si necesita agregar un script al marcado, ingresa el código JavaScript allí.

```HTML
<!DOCTYPE html>
<html>
<head>
<script> Tu guión podría estar aquí </script>
</head>
```
Pero más a menudo, simplemente se inserta un enlace a un archivo en la página: esto le permite usar un script en muchas páginas y no editar cada una de ellas.

### Multiparadigma
Hay tres paradigmas principales en programación:

* Objeto: opera sobre funciones y un conjunto de datos, y el código se construye como un sistema de relaciones entre ellos.
* Funcional: utilice funciones matemáticas. Debido a la ausencia de variables que cambien valores, el resultado de las consultas en este paradigma es siempre el mismo.
* En imperativo, utilizan variables a las que se asignan valores e instrucciones que se ejecutan de forma secuencial.

La peculiaridad de JavaScript es que el lenguaje permite utilizar cualquiera de estos paradigmas, lo que le da al desarrollador una mayor libertad de decisión a la hora de escribir código.

### Escritura dinámica

Los lenguajes de programación utilizan un conjunto de reglas para dividir la información en clases; esto se llama mecanografía. En JavaScript es dinámico. Esto significa que al crear una variable, no es necesario especificar su tipo, es decir, asignarla a un grupo de datos específico.

## Beneficios de JavaScript

* Plataforma independiente. Si quieres ejecutar un programa en JavaScript, no necesitas instalar aplicaciones adicionales: cualquier navegador lo hará. Otros lenguajes requerirán la instalación de un compilador que ejecutará el código o un entorno de desarrollo (IDE).
* Poco exigente. Dado que JavaScript ejecuta el código en el navegador, el programa que contiene no carga el servidor y el tiempo de respuesta es mínimo. Por ejemplo, cuando se le ocurre una nueva contraseña, aparece instantáneamente una notificación de que no es lo suficientemente compleja. Esto es gracias a JavaScript.
* Fácil de aprender. JavaScript es uno de los lenguajes de programación más sencillos. Al mismo tiempo, cuenta con una enorme comunidad y una gran cantidad de herramientas que facilitan la vida del desarrollador.

## Desventajas de JavaScript

* Problema de tipo de datos. Las variables en JavaScript pueden cambiar su tipo de datos durante la ejecución del programa. Imaginemos que tenemos una variable que dice "1000". Esta entrada puede ser un número o simplemente el contenido de una línea: texto. Agregar una cadena y un número es imposible en la mayoría de los lenguajes de programación. Y JavaScript puede simplemente generar el resultado del cálculo. Debido a esto, aparecen errores inesperados en el código, que pueden ser difíciles de encontrar.

```JavaScript
const sum = (num1, num2) => num1 + num2
sum(1, 2) // 3
sum('hello', 2) // 'hello2'
```
* Demasiadas bibliotecas y marcos adicionales. Para aprovechar al máximo JavaScript, necesita herramientas adicionales. Elegirlos es una tarea difícil en sí misma. Es necesario que no entren en conflicto entre sí, interactúen correctamente y su apoyo no se detenga en un momento desagradable. La principal desventaja para un nuevo programador de JavaScript es que para comenzar una carrera en desarrollo comercial, necesitará aprender varias herramientas. Y luego pasar a un nuevo proyecto, algunos más.
* Problemas de desempeño. La interpretabilidad de JavaScript generalmente se considera una ventaja, pero a veces se convierte en una desventaja. Al procesar grandes cantidades de datos, las operaciones pueden ser menos eficientes que en otros lenguajes.
***

# ¿Cuáles son algunos tipos de datos JS?

Hay varios tipos de datos básicos en JavaScript.

**Número "number"**
```JavaScript
var n = 123;
n = 12.345;
```
El tipo de *número* único se utiliza tanto para números enteros como para fracciones.

Hay valores numéricos especiales Infinity (infinito) y NaN (error de cálculo).

Por ejemplo, el Infinito se obtiene dividiendo por cero:
```JavaScript
alert( 1 / 0 ); // Infinity
```
Un error de cálculo de NaN será el resultado de una operación matemática incorrecta, por ejemplo:
```JavaScript
alert( "no número" * 2 ); // NaN, error
```
Estos valores pertenecen formalmente al tipo “número”, aunque, por supuesto, no son números en su sentido habitual.

**Número «bigint»**
En JavaScript, el tipo "número" no puede contener números mayores que 2\**53 (o menores que -2\**53 para los negativos). Esta limitación técnica se debe a su representación interna. 253 es un número bastante grande que consta de 16 dígitos, por lo que la mayoría de las veces no habrá problemas. Pero a veces necesitamos números realmente gigantescos, por ejemplo en criptografía o cuando utilizamos marcas de tiempo con microsegundos.

El tipo Bigint se agregó a JavaScript para brindar la capacidad de trabajar con números enteros de longitud arbitraria.

Para crear un valor Bigint, debe agregar n al final del literal numérico:
```JavaScript
// la "n" al final significa que es Bigint
const bigint = 1234567890123456789012345678901234567890n;
```

**Cadena "string"**
```JavaScript
var str = "Mamá lavó el marco";
str = 'Las comillas simples también funcionarán';
```
En JavaScript, las comillas simples y dobles son equivalentes. Puedes usar uno u otro.

**Tipo booleano (lógico) “boolean”**
Tiene sólo dos valores: true (verdadero) y false (falso).
Normalmente, este tipo se utiliza para almacenar un valor de sí/no, por ejemplo:
```JavaScript
var checked = true; // el campo del formulario está marcado con una marca de verificación
checked = false;    // el campo del formulario no contiene una marca de verificación
```

**Valor especial "null"**
El valor null no pertenece a ninguno de los tipos anteriores, sino que forma su propio tipo, que consta de un único valor null:
```JavaScript
var age = null;
```
En JavaScript, null no es una "referencia a un objeto inexistente" o un "puntero nulo" como en otros lenguajes. Es simplemente un valor especial que tiene el significado de "nada" o "valor desconocido".

Específicamente, el código anterior dice que se desconoce la edad.

**Valor especial "undefined"**
El valor undefined, como null, forma su propio tipo que consta de este valor. Tiene el significado de "sin valor asignado".

Si se declara una variable, pero no se escribe nada en ella, entonces su valor está undefined:
```JavaScript
var x;
alert(x); // imprimirá "undefined"
```
También puedes asignar undefined explícitamente, aunque esto rara vez se hace:
```JavaScript
var x = 123;
x = undefined;

alert(x); // "undefined"
```
Por lo general, undefined no se asigna explícitamente, ya que esto contradeciría su significado. Para escribir un valor "vacío" o "desconocido" en una variable, se utiliza null.

**symbol**
El "symbol" representa un identificador único.

Los nuevos símbolos se crean usando la función Symbol():
```JavaScript
// Crea un nuevo símbolo - id
let id = Symbol();
```
Cuando crea un símbolo, puede darle una descripción (también llamada nombre), que se utiliza principalmente para depurar código:
```JavaScript
// Crea un símbolo id con una descripción (nombre) "id"
let id = Symbol("id");
```
Se garantiza que los símbolos serán únicos. Incluso si creamos muchos símbolos con la misma descripción, seguirán siendo símbolos diferentes. La descripción es sólo una etiqueta que no afecta en nada.

Por ejemplo, aquí hay dos sýmbolos con la misma descripción, pero no son iguales:
```JavaScript
let id1 = Symbol("id");
let id2 = Symbol("id");

alert(id1 == id2); // false
```
**"Object"**
Los primeros 7 tipos se denominan "primitivos".
Destaca el octavo tipo: los “objetos”.
Se utiliza para colecciones de datos y para declarar entidades más complejas.
Los objetos se declaran utilizando llaves {...}, por ejemplo:
```JavaScript
var user = { name: "Ana" };
```

**Operador "typeof"**

El operador typeof devuelve el tipo de argumento.

Tiene dos sintaxis: con y sin paréntesis:
1. Sintaxis del operador: typeof x.
2. Sintaxis de la función: typeof (x).

Funcionan igual, pero la primera sintaxis es más corta.

El resultado de typeof es una cadena que contiene el tipo:
```JavaScript
typeof undefined // "undefined"

typeof 0 // "number"

typeof 1n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol() // "symbol"

typeof {} // "object"

typeof null // "object"  (1)

typeof function(){} // "function"  (2)
```
En dos últimas líneas typeof se comporta de manera diferente en ellas.

1. El resultado typeof null == "object" es un error oficialmente reconocido en el lenguaje que se conserva por compatibilidad. De hecho, null no es un objeto, sino un tipo de datos independiente.
2. Typeof separa funciones devolviendo "function" para ellas. En la práctica, esto es bastante conveniente porque facilita la definición de una función.
***

# ¿Cuáles son las tres funciones de String en JS?

Para crear cadenas, podemos asignar directamente una cadena a una variable o constante:
```JavaScript
const message = "Hello";
```
El objeto String está diseñado para funcionar con cadenas, por lo que también puedes usar el constructor String:
```JavaScript
const message = new String("Hello");
```
Pero, por regla general, se utiliza el primer método, más breve. En el primer caso, JavaScript convierte automáticamente la variable de tipo primitivo en un objeto String si es necesario.

Usando índices, puede acceder a caracteres individuales en una cadena como si fueran elementos de una matriz (como en las matrices, la indexación comienza desde cero):
```JavaScript	
const message = "Hello";
console.log(message[0]);    // H 
console.log(message[4]);    // o
```
El objeto String tiene un gran conjunto de propiedades y métodos con los que podemos manipular cadenas.

## Longitud de la cadena
La propiedad length indica la longitud de la cadena:
```JavaScript
const message = "Hello";
console.log(message.length);        //  5 símbolos
```

## Repetición de cadena
El método repeat() le permite crear una cadena repitiendo otra cadena una y otra vez. El número de repeticiones se pasa como argumento:
```JavaScript
const message = "hello ";
console.log(message.repeat(3)); // hello hello hello
```
## Buscar en una cadena
**indexOf/lastIndexOf**

Para buscar una cadena para una determinada subcadena, se utilizan los métodos indexOf() (índice de la primera aparición de la subcadena) y lastIndexOf() (índice de la última aparición de la subcadena). Estos métodos toman dos parámetros:
```JavaScript
indexOf(str, index)
lastIndexOf(str, index)
```
* Subcadena para encontrar
* Índice desde el que se realiza la búsqueda (Parámetro opcional)

Ambos métodos devuelven el índice del carácter en el que comienza la subcadena en la cadena. Si no se encuentra la subcadena, se devuelve el número -1.
```JavaScript
const hello = "hello world. bye world";
const key = "world";
const firstPos = hello.indexOf(key);
const lastPos = hello.lastIndexOf(key);
console.log("Primera ocurrencia: ", firstPos);    // 7
console.log("Ultima ocurrencia: ", lastPos);  // 17
```
Busquemos en relación con el índice, por ejemplo, comenzando desde el índice 10:
```JavaScript
const hello = "hello world. bye world";
const key = "world";
const firstPos = hello.indexOf(key, 10);    // buscar desde el índice 10
console.log("Primera ocurrencia: ", firstPos);    // 17
```
Tenga en cuenta que la búsqueda distingue entre mayúsculas y minúsculas:
```JavaScript
const hello = "hello world. bye world";
const key = "World";
const firstPos = hello.indexOf(key);
console.log(firstPos);  // -1
```
## includes
Otro método: includes() devuelve true si la cadena contiene una subcadena determinada.
```JavaScript
const hello = "hello world. bye world";
 
console.log(hello.includes("world")); // true
console.log(hello.includes("moment")); // false
```
Usando el segundo parámetro adicional, puede determinar el índice desde el cual comenzará la búsqueda de la subcadena:
```JavaScript
const hello = "hello world. bye world";
 
console.log(hello.includes("world", 5));  // true
console.log(hello.includes("hello", 6));   // false
```
## Substring selection
Para cortar una subcadena de una cadena, use los métodos substring() y slice().

### Substring
El método substring() toma dos parámetros:
```JavaScript
substring(startIndex, endIndex)
```
* índice del carácter en la cadena, a partir del cual se debe recortar la cadena. Parámetro requerido
* El índice al que se debe recortar la cadena. Parámetro opcional: si no se especifica, el resto de la línea se trunca
```JavaScript
const hello = "hello world. bye world";
const world = hello.substring(7, 10); // de 7 a 10 índice
console.log(world); // world
const bye = hello.substring(12);    // de 12 índice hasta el final de la cadena
console.log(bye); // bye world
```
### slice
El método slice también le permite obtener una parte de una cadena. Se necesitan dos parámetros:
```JavaScript
slice(startIndex, endIndex)
```
* El índice inicial de la subcadena en la cadena. Parámetro requerido
* El índice final de la subcadena en la cadena. Parámetro opcional: si no se especifica, el resto de la línea se trunca
```JavaScript
const hello = "hello world. bye world";
const world = hello.slice(7, 10); // de 7 a 10 índice
console.log(world); // world
const bye = hello.slice(12);    // de 12 índice hasta el final de la cadena
console.log(bye); // bye world
```
Notarás que este método es similar al método substring(), sin embargo, existen ligeras diferencias entre ellos. En primer lugar, en slice() el índice inicial debe ser menor que el índice final. En substring(), si el índice inicial es mayor que el índice final, entonces se intercambian (es decir, substring(5, 1) será equivalente a substring(1, 5)):
```JavaScript
const hello = "hello world. bye world";
const world1 = hello.slice(6, 0); // no funciona
console.log(world1); //     linea vacia
const world2 = hello.substring(6, 0); // similarmente hello.substring(0, 6)
console.log(world2); // hello
```
Otra diferencia es que el slice permite el uso de índices negativos. Un índice negativo indica el índice del carácter relativo al final de la cadena. substring() no admite índices negativos:
```JavaScript
const hello = "hello world. bye world";
const bye1 = hello.slice(-8, -4); // de 8 índice del final al 4 índice del final
console.log(bye1); // bye
const bye2 = hello.substring(-8, -4); // no funciona 
console.log(bye2); // 
```
### substr
Cabe señalar que también existe un método substr(). Este método no forma parte del estándar y, por lo general, no se recomienda su uso, pero es posible que aún sea compatible con los navegadores y se pueda encontrar en varios programas. Se necesitan dos parámetros:
```JavaScript
substr(startIndex, count)
```
* El índice inicial de la subcadena en la cadena. Parámetro requerido
* Número de caracteres seleccionables. Parámetro opcional: si no se especifica, se selecciona el resto de la cadena

Solicitud:
```JavaScript
const hello = "hello world. bye world";
const world = hello.substr(7, 3); // de 7 índice del 3 símbolo
console.log(world); // world
const bye = hello.substr(12); // de 12 índice al final 
console.log(bye); // bye world
```
## Gestión de casos

Para cambiar el caso de los caracteres, existen métodos toLowerCase() (para convertir a minúsculas) y toUpperCase() (para convertir a mayúsculas).
```JavaScript
const hello = "Hello Tom";
console.log(hello.toLowerCase()); // hello tom
console.log(hello.toUpperCase()); // HELLO TOM
```
## Obtener un símbolo por índice

Para obtener un carácter específico en una cadena por índice, puede usar la sintaxis de matriz. Pero JavaScript también proporciona los métodos charAt() y charCodeAt(). Ambos métodos toman el índice de caracteres como parámetro:
```JavaScript	
const hello = "Hello Tom";
console.log(hello.charAt(2));       // l
console.log(hello.charCodeAt(2));   // 108
```
Pero si el método charAt() devuelve el carácter como resultado, entonces el método charCodeAt() devuelve el código numérico de este carácter.

## Eliminando espacios

Para eliminar los espacios iniciales y finales de una cadena, utilice el método trim():
```JavaScript
let hello = "   Hello Tom   ";
const beforeLength = hello.length;
hello = hello.trim();
const afterLength = hello.length;
console.log("Longitud de línea hasta: ", beforeLength);     // 15
console.log("Longitud de línea después: ", afterLength);   // 9
```
Además, existen varios métodos que eliminan espacios de un lado específico de una cadena:

* trimStart(): elimina el espacio desde el principio de una línea (dependiendo de si la letra es diestra o zurda, este puede ser el borde derecho o izquierdo de la línea)
* trimEnd(): elimina un espacio al final de una línea (dependiendo de si la letra es diestra o zurda, este puede ser el borde derecho o izquierdo de la línea)
* trimLeft(): elimina el espacio del lado izquierdo de una cadena
* trimRight(): elimina los espacios en blanco del lado derecho de una cadena

## Concatenar cadenas

El método concat() concatena dos cadenas:
```JavaScript	
let hello = "Hello ";
const world = "world";
hello = hello.concat(world);
console.log(hello); // Hello world
```
## Reemplazo de subcadena

El método replace() reemplaza la primera aparición de una subcadena por otra:
```JavaScript
let hello = "Good morning";
hello = hello.replace("afternoon", "evening");
console.log(hello); // Good evening
```
El primer parámetro del método especifica qué subcadena debe reemplazarse y el segundo parámetro especifica con qué subcadena debe reemplazarse.

Al mismo tiempo, este método tiene una característica: reemplaza solo la primera aparición de la subcadena:
```JavaScript
let menu = "breakfast: porridge, tea. Lunch: soup, tea. Dinner: salad, tea.";
menu = menu.replace("tea", "coffee");
console.log(menu);  // Breakfast: porridge, coffee. Lunch: soup, tea. Dinner: salad, tea.
```
Sin embargo, otro método, replaceAll(), le permite reemplazar todas las apariciones de una subcadena:
```JavaScript
let menu = "Breakfast: porridge, tea. Lunch: soup, tea. Dinner: salad, tea.";
menu = menu.replaceAll("tea", "coffee");
console.log(menu);  // Breakfast: porridge, coffee. Lunch: soup, coffee. Dinner: salad, coffee.
```
## División de cadena

El método split() divide una cadena en una matriz de subcadenas utilizando un delimitador específico. El separador es una cadena que se pasa al método:
```JavaScript
const message = "The weather was beautiful today";
const messageParts = message.split(" ");
console.log(messageParts);  // ["Today", "was", "beautiful", "weather"]
```
En este caso, la línea se divide por espacios, es decir, al final habrá cuatro elementos en la matriz messageParts.

## Comprobar el principio y el final de una cadena

El método startWith() devuelve true si la cadena comienza con una subcadena específica. Y el método endsWith() devuelve true si la cadena termina con una subcadena específica.
```JavaScript
const hello = "let me speak from my heart";
console.log(hello.startsWith("let"));       // true
console.log(hello.startsWith("Let"));       // false
console.log(hello.startsWith("lets"));      // false
 
console.log(hello.endsWith("heart"));       // true
console.log(hello.startsWith("bart"));      // false
```
El caso juega un papel aquí y en el ejemplo anterior podemos ver que "let" no es equivalente a "Let".

Un segundo parámetro adicional le permite especificar el índice (para startsWith el índice del principio y para endsWith, el índice del final de la cadena) con respecto al cual se realizará la comparación:
```JavaScript
const hello = "let me speak from my heart";
console.log(hello.startsWith("me", 4));     // true, "me" - 4 índice del principio de la cadena
 
console.log(hello.startsWith("my", hello.length-8));    // true, "my" - 8 índice del final
```
## Llenando una línea

Los métodos padStart() y padEnd() estiran la cadena hasta un cierto número de caracteres y rellenan la cadena a la izquierda y a la derecha, respectivamente.
```JavaScript
let hello = "hello".padStart(8);  // "   hello"
console.log(hello);
hello = "hello".padEnd(8);      // "hello   "
console.log(hello);
```
Llamar a "hello".padStart(8) ampliará la cadena "hello" a 8 caracteres. Es decir, inicialmente hay 5 caracteres en la línea "hello", lo que significa que se le agregarán 3 caracteres. Además, se agregarán al principio de la línea. De forma predeterminada, los caracteres agregados representan espacios. De manera similar, llamar a "hello".padEnd(8) ampliará la cadena a 8 caracteres, pero los caracteres restantes en forma de espacios se agregarán al final de la cadena.

Por defecto, estos métodos usan espacios para el relleno, pero como segundo parámetro podemos pasarle a los métodos el valor con el que rellenar la cadena:
```JavaScript
let hello = "hello".padStart(17, "JavaScript, ");  // "JavaScript, hello"
hello = "hello".padEnd(12, " Eugene");      // "hello Eugene"
```
Si el número agregado de caracteres es mayor que la línea agregada, entonces la línea agregada se repite:
```JavaScript
let hello = "123".padStart(6, "0");  // "000123"
hello = "123".padEnd(6, "0");       // "123000"
```
***

# ¿Qué es un condicional?

Las construcciones condicionales le permiten realizar determinadas acciones dependiendo de determinadas condiciones.

## Construcción if..else
La construcción if..else verifica alguna condición y, si esta condición es verdadera, realiza algunas acciones. La forma más simple de la construcción if..else es:
```JavaScript
if(condición){
     
    algunas acciones
}
```
Después de la palabra clave if, hay una condición entre paréntesis y después de la condición hay un bloque de código con algunas acciones. Si esta condición es verdadera, entonces se ejecutan las acciones que se colocan en el bloque de código.

Por ejemplo:
```JavaScript
const income = 100;
if(income > 50) {
     
    console.log("income more than 50");
}
```
Aquí la cláusula if utiliza la siguiente condición: income > 50. Si esta condición devuelve true, es decir, si la constante income tiene un valor más que 50, entonces el navegador muestra un mensaje. Si el valor del income es menos a 50, no se muestra ningún mensaje.

Si un bloque de código contiene una sola declaración, como en el caso anterior, entonces el diseño se puede simplificar eliminando las llaves y colocando las acciones inmediatamente después de la condición:
```JavaScript
const income = 100;
if(income > 50) console.log("income more than 50");
```
o mover acciones a la siguiente línea
```JavaScript
const income = 100;
if(income > 50) 
    console.log("income more than 50");
```
Además, las condiciones pueden ser complejas:
```JavaScript
const income = 100;
const age = 19;
if(income > 50 && age > 18){
 
    console.log("income more than 50");
    console.log("age over 18");
}
```
## Проверка наличия значения

La construcción if le permite verificar la presencia de un valor. 
Por ejemplo:
```JavaScript
let myVar = 89;
if(myVar){
     
    console.log(`La variable myVar tiene un valor: ${myVar}`);
}
```
Si myVar tiene un valor, como lo tiene aquí, devolverá true en el condicional.
Opción opuesta:
```JavaScript
let myVar;
if(myVar){
    console.log(`La variable myVar tiene un valor: ${myVar}`);
}
```
Aquí la variable myVar no tiene valor. (En realidad, está undefined) Por lo tanto, la condición en la cláusula if devolverá false y las acciones en el bloque de la cláusula if no se ejecutarán.

Pero a menudo, para comprobar el valor de una variable, utilizan una opción alternativa: comprueban el valor undefined y null:
```JavaScript
if (myVar !== undefined && myVar !== null) {
    console.log(`La variable myVar tiene un valor: ${myVar}`);
}
```
## Expresión else

Arriba vimos cómo definir las acciones que se realizan si la condición después de if es verdadera. ¿Pero qué pasa si también queremos ejecutar otro conjunto de instrucciones si la condición es falsa? En este caso, puedes usar un bloque else. Este bloque contiene instrucciones que se ejecutan si la condición después de if es falsa, es decir, igual a falso:
```JavaScript
if(condición){
    acciones, si la condición es verdadera
}
else{
    acciones, si la condición es falso
}
```
Es decir, si la condición después de if es verdadera, se ejecuta el bloque if. Si la condición es falsa, se ejecuta el bloque else. Por ejemplo:
```JavaScript	
const income = 45;
if(income > 50){
 
    console.log("Income more than 50");
}
else{
    console.log("Income less than or equal to 50");
}
```
Aquí la constante income es 45, por lo que la condición después de la declaración if devolverá false y el control pasará al bloque else.

Además, si el bloque else contiene una instrucción, entonces puedes acortar la construcción:
```JavaScript
const income = 45;
if(income > 50) console.log("Income more than 50");
else console.log("Income less than or equal to 50");
```
## Condiciones alternativas y else if

Con la construcción else if, podemos agregar una condición alternativa a un bloque if. Por ejemplo, en la condición anterior, el valor del income puede ser mayor que cierto valor, puede ser menor o puede ser igual a él. Reflejemos esto en el código:
```JavaScript
const income = 50;
if(income > 50) {
    console.log("Income more than 50");
}
else if(income === 50){
    console.log("Income equel to 50");
}
else{
    console.log("Income less than 50");
}
```
En este caso, se ejecutará el bloque else if. Si es necesario, podemos utilizar varios bloques else if con diferentes condiciones:
```JavaScript
const income = 500;
if(income < 200){
 
    console.log("Income below average");
}
else if(income>=200 && income<300){
     
    console.log("Slightly below average");
}
else if(income>=300 && income<400){
     
    console.log("Average income");
}
else{
    console.log("Above average income");
}
```
En este caso no es necesario utilizar el bloque else:
```JavaScript
const income = 500;
if(income < 200){
 
    console.log("Income below average");
}
else if(income>=200 && income<300){
     
    console.log("Slightly below average");
}
else if(income>=300 && income<400){
     
    console.log("Average income");
}
```
## True o false

En javascript, cualquier variable se puede utilizar en expresiones condicionales, pero no todas las variables son de tipo boolean. Y en este sentido, surge la pregunta: ¿qué devolverá tal o cual variable: true o false? Mucho depende del tipo de datos que representa la variable:
* undefined. Devuelve false
* null. Devuelve false
* boolean. Si la constante/variable es false, se devuelve false. En consecuencia, si la constante/variable es true, entonces se devuelve true.
* number. Devuelve false si el número es 0 o NaN (Not a Number); de lo contrario, devuelve true.
Por ejemplo, la siguiente variable devolverá false:
```JavaScript	
let x = NaN;
if(x){  // false
        
}
```
* String. Devuelve false si la constante/variable es igual a la cadena vacía, es decir, su longitud es 0, en caso contrario devuelve true 
```JavaScript
const emptyText = "";   // false - porque es una cadena vacía
const someText = "javascript";  // true - la cadena no está vacía
```
* Object. Siempre devuelve true
```JavaScript
const user = {name:"Tom"};  // true
const car = {}; // true
```
## Construcción switch..case

La construcción switch..case es una alternativa al uso de la construcción if..else y también le permite manejar múltiples condiciones a la vez: 
```JavaScript
const income = 200;
switch(income){
 
    case 100 : 
        console.log("Income is 100");
        break;
    case 200 : 
        console.log("Income is 200");
        break;
    case 500 : 
        console.log("Income is 500");
        break;
}
```
Después de la palabra clave switch, la expresión que se va a comparar viene entre paréntesis. El valor de esta expresión se compara secuencialmente con los valores colocados después del operador case. Y si se encuentra una coincidencia, se ejecutará un bloque específico case.

Se coloca una declaración break al final de cada bloque case para evitar la ejecución de otros bloques. En este caso, la constante income es 200, por lo que se ejecutará el bloque.
```JavaScript
case 200 : 
    console.log("Income is 200");
    break;
```
## Declaración break

La declaración break se utiliza para evitar que se cumplan otras condiciones. Por ejemplo, podríamos escribir:
```JavaScript
let income = 200;
switch(income){
  
    case 100 : 
        console.log("Income is 100");
        income +=100;
        break;
    case 200 : 
        console.log("Income is 200");
        income +=100;
        break;
    case 500 : 
        console.log("Income is 500");
        income +=100;
        // break;   // no tiene sentido en break, ya que el último bloque
}
```
Aquí nuevamente income es 200 y nuevamente se ejecutará el bloque.
```JavaScript
case 200 : 
    console.log("Income is 200");
    income +=100;
    break;
```
Gracias a la declaración break, después de ejecutar el bloque, la construcción switch saldrá y no se ejecutará ningún otro bloque case.

Pero ahora eliminemos la declaración break:
```JavaScript
let income = 200;
switch(income){
  
    case 100 : 
        console.log("Income is 100");
        income +=100;
    case 200 : 
        console.log("Income is 200");
        income +=100;
    case 500 :
        console.log("Income is 500");
        income +=100;
}
console.log("The final income is", income);
```
Resultado de la ejecución:
Income is 200
Income is 500
Final income is 400

Aquí, inicialmente la variable income vuelve a ser igual a 200, en consecuencia se ejecutará el bloque
```JavaScript
case 200 : 
    console.log("Income is 200");
    income +=100;
```
El valor de income se incrementa en 100, pero no hay una declaración break al final del bloque, por lo que el control pasará a verificar la condición en el siguiente bloque:
```JavaScript
case 500 : 
    console.log("Income is 500");
    income +=100;
```
Y no importa que income no sea igual a 500 (sino solo 300 por el momento), este bloque también se ejecutará.

## Combinando condiciones

Sin embargo, si es necesario, puedes procesar varias condiciones a la vez:
```JavaScript
const income = 200;
switch(income){
 
    case 100 :
    case 200 :
        console.log("Income is 100 o 200");
        break;
    case 500 : 
        console.log("Income is 500");
        break;
}
```
En este caso, para la condición en la que income son igual a 100 y 200, se realizan las mismas acciones.
Condición predeterminada: default

Si también queremos manejar la situación en la que no se encuentra ninguna coincidencia, podemos agregar un bloque predeterminado default:
```JavaScript
const income = 700;
switch(income){
 
    case 100 : 
        console.log("Income is 100");
        break;
    case 200 : 
        console.log("Income is 200");
        break;
    case 500 : 
        console.log("Income is 500");
        break;
    default: 
        console.log("Unknown income");
        break;
}
```

***

# ¿Qué es un operador ternario?

Los operadores ternarios (también conocidos como operadores condicionales) son una poderosa herramienta en JavaScript que simplifica su código y lo hace más legible. Se utilizan para ejecutar una de dos expresiones dependiendo de si una condición determinada es verdadera o falsa.

En general, el operador ternario tiene la siguiente forma: condición ? expresión1: expresión2. En este caso, si la condición es verdadera, entonces se ejecuta la expresión1; de lo contrario, se ejecuta la expresión2.

La función de los operadores ternarios en la programación es que le permiten reducir la cantidad de código escrito para operaciones condicionales, haciéndolo más legible y más fácil de entender. Pueden ser una herramienta eficaz para incrustar expresiones condicionales dentro de otras expresiones o declaraciones.

## Sintaxis del operador ternario en JavaScript

Veamos la estructura del operador ternario de JavaScript y ejemplos de su uso. 

El operador ternario es el único operador en JavaScript que toma tres operandos: una condición, luego una expresión que se ejecuta si la condición es verdadera, separada por un signo de interrogación (?), y finalmente una expresión que se ejecuta si la condición es falsa, separados por dos puntos (:). A menudo se utiliza como una forma abreviada de la declaración if...else.

A continuación se muestran ejemplos del uso de la sintaxis en el código...
* para determinar el valor máximo:
```JavaScript
var a = 5;

var b = 10;

var max = (a > b) ? a : b;

console.log(max); // Will output: 10
```
* para definir un mensaje de estado de usuario:
```JavaScript
var isLoggedIn = true;

var statusMessage = isLoggedIn ? "You are logged in" : "Please login";

console.log(statusMessage); // Displays: "You are logged in"
```
* para comprobar un valor y asignar un valor predeterminado:
```JavaScript
var errorMessage = null;

var message = errorMessage ? errorMessage : "No mistakes";

console.log(message); // Outputs: "No errors"
```
Un ejemplo del uso del operador ternario dentro de otra expresión:
```JavaScript
var age = 20;

var status = (age >= 18) ? "Adult": "Minor";

console.log(status); // Will display: "Adult"
```
Estos ejemplos demuestran el uso del operador ternario en diversas situaciones en las que una condición determina la elección entre dos valores en función de su verdad o falsedad.

## Beneficios de uso
Los operadores ternarios ofrecen varias ventajas importantes:

* Simplificando el código
Uno de los beneficios clave es la capacidad de reducir el volumen de código, especialmente en condiciones simples. En lugar de utilizar sentencias if-else completas, puede utilizar el operador ternario, que requiere menos caracteres y hace que el código sea más conciso.

* Legibilidad mejorada
El código se vuelve más legible, especialmente cuando la condición y su resultado son breves y claros. El uso adecuado de operadores ternarios puede hacer que el código sea más expresivo y reducir la cantidad de líneas redundantes, lo que mejora la comprensión del código tanto para el programador como para otros desarrolladores.

* Carga de memoria reducida
En comparación con las declaraciones if-else completas, los operadores ternarios ocupan menos espacio en el código fuente, lo que puede ser especialmente importante en entornos restringidos o cuando se trabaja con recursos limitados.

* Aplicación en programación funcional.
Cuando las funciones suelen tener bloques de código cortos y claros, los operadores ternarios pueden resultar especialmente útiles para expresar condiciones simples sin expandir innecesariamente el código.

## Comparación con if-else
Al comparar operadores ternarios con condicionales tradicionales if-else, se deben considerar tanto sus ventajas como sus desventajas.
1.  Ventajas
* Compacidad del código: los operadores ternarios suelen ocupar menos espacio en el código fuente que los condicionales if-else similares. Le permiten reducir la cantidad de código y hacerlo más conciso.
* Legibilidad: en condiciones simples, los operadores ternarios pueden hacer que el código sea más comprensible y expresivo. Pueden ser más naturales de leer, especialmente si la condición y su resultado son fácilmente reconocibles.
* Uso en expresiones: se puede usar dentro de otras expresiones, lo que reduce la cantidad de variables temporales y hace que el código sea más compacto.

2. Defectos
* Limitación de la complejidad de las condiciones: no siempre son adecuadas para condiciones complejas con muchas ramas. En tales casos, utilizar condicionales completos if-else puede ser más conveniente y comprensible.
* Disminución de la legibilidad si se usan en exceso: su uso excesivo e innecesario puede provocar una mala legibilidad del código y hacerlo más difícil de entender.
* Inconvenientes de depuración: en algunos casos, depurar código que contiene muchos operadores ternarios anidados puede resultar difícil. En tales situaciones, puede ser preferible utilizar condicionales completos if-else.

## Usos comunes de operadores ternarios en JavaScript
Los operadores ternarios pueden ayudar a simplificar el código en una variedad de situaciones de programación. Veamos algunos ejemplos de su uso:

* Permite asignar valores a variables en función del cumplimiento de una determinada condición. Por ejemplo:
```JavaScript
var isAdult = (age >= 18) ? true : false;
```
* Le permite seleccionar mensajes para mostrar según ciertas condiciones. Esto simplifica el código, haciéndolo más conciso y comprensible. Por ejemplo:
```JavaScript
var message = (isLoggedIn) ? "Welcome!" : "Please login.";
```
* Te ayudan a elegir uno de dos valores dependiendo de si se cumple o no una determinada condición. Por ejemplo:
```JavaScript
var result = (score >= 50) ? "Congratulations! You passed the test." : "Sorry, you failed the test.";
```
* En el desarrollo web, te permiten configurar clases CSS dinámicamente dependiendo de ciertas condiciones. Por ejemplo:
```JavaScript
element.className = (isValid) ? "valid" : "invalid";
```
* Los operadores ternarios le permiten probar la presencia o ausencia de valores y realizar las acciones apropiadas en función del resultado. Por ejemplo:
```JavaScript
var message = (errorMessage) ? errorMessage : "No mistakes.";
```
* Le permite filtrar elementos de la matriz según ciertas condiciones. Por ejemplo:
```JavaScript
var filteredArray = array.filter(item => (item.isActive) ? item : null);
```
Todos estos ejemplos demuestran cómo los operadores ternarios se pueden usar de manera efectiva para una variedad de tareas en JavaScript, haciendo que el código sea más compacto y legible. Sin embargo, debe tener en cuenta el equilibrio entre el uso de operadores ternarios y la legibilidad del código para evitar complicarlo.

## Características y limitaciones

Los operadores ternarios son una herramienta poderosa para realizar operaciones condicionales en JavaScript, pero su uso no siempre es práctico o conveniente. Consideremos sus características y limitaciones:

1. Peculiaridades
* Tienen una sintaxis simple y concisa, lo que los hace convenientes para usar en entornos simples.
* Una de sus principales ventajas es la capacidad de reducir la cantidad de código, especialmente en condiciones simples.
* Se pueden utilizar dentro de otras expresiones, lo que las hace útiles para representar condiciones de forma compacta.

2. Restricciones
* En entornos complejos con muchas ramas, su uso puede hacer que el código sea menos legible y más difícil de entender.
* No pueden contener efectos secundarios en sus expresiones, como llamadas a funciones o cambios en el estado de los objetos. Su uso para operaciones complejas puede resultar poco práctico.
* Los operadores ternarios anidados pueden hacer que el código sea más difícil de depurar y detectar errores, especialmente para nuevos desarrolladores o cuando se trabaja en equipo.

Entonces la pregunta es: ¿cuándo podría ser inapropiado utilizar operadores ternarios? En primer lugar, cuando las condiciones se vuelven complejas con muchas opciones de ramificación. En segundo lugar, si una afección contiene efectos secundarios o requiere muchas operaciones, su uso se vuelve ineficaz y difícil de entender. Además, el uso excesivo de operadores ternarios puede tener un impacto negativo en la legibilidad del código, especialmente si ocurren en grandes cantidades.

En general, al elegir entre utilizar operadores ternarios y condicionales completos if-else, es importante considerar sus circunstancias específicas y esforzarse por lograr un equilibrio entre lo compacto y la legibilidad de su código.

## Mejores prácticas y consejos
Para hacer un uso óptimo de los operadores ternarios, es importante seguir algunas pautas y mejores prácticas. En primer lugar, intente utilizarlos sólo en condiciones sencillas y comprensibles. Si la condición es demasiado compleja, es mejor utilizar condicionales estándar para que el código sea más legible. No abuse del anidamiento de operadores ternarios, ya que esto puede complicar el código y dificultar su comprensión. Es mejor dividir condiciones complejas en varias partes o utilizar condicionales completos if-else.

En segundo lugar, los operadores ternarios son buenos para asignar valores a variables según condiciones, lo que hace que el código sea más compacto y expresivo. Sin embargo, es importante mantener la legibilidad del código y cumplir con los estándares de codificación. Recuerde que el objetivo principal del código es ser legible y comprensible.

En tercer lugar, es importante probar el código en busca de errores y analizar su comportamiento en diversas condiciones. Esto ayudará a garantizar que los operadores ternarios funcionen correctamente y evitar posibles problemas. Si trabaja en equipo, analice las preferencias de uso con otros desarrolladores y cumpla con los estándares establecidos para garantizar un estilo de codificación coherente.


Los operadores ternarios son una herramienta poderosa para simplificar expresiones condicionales en JavaScript. Y usarlos correctamente ayuda a que su código sea más conciso y legible, lo que ayuda a mejorar la eficiencia y la capacidad de mantenimiento de su código.

Sin embargo, debe recordar encontrar un equilibrio entre lo compacto y la legibilidad del código, para no dificultar su comprensión al final.

***

# ¿Cuál es la diferencia entre una declaración de función y una expresión de función?

Las declaraciones de funciones se utilizaron durante mucho tiempo, pero fueron reemplazadas gradualmente por expresiones de funciones. Muchos desarrolladores no están seguros de cuándo usar un método de declaración de función en particular, por lo que terminan usando el incorrecto.

Existen varias diferencias clave entre expresiones de funciones y declaraciones de funciones. 
```JavaScript
function funcDeclaration() {
    return 'Function Declaration';
}

let funcExpression = function () {
    return 'Function expression';
}
```

## ¿Qué es una declaración de función?

Una declaración de función es cuando creas una función y le das un nombre. Declaras el nombre de una función cuando escribes la palabra clave de la function seguida del nombre de la función. Por ejemplo:
```JavaScript
function myFunction() {
  // we do something
};
```

Como puede ver, el nombre de la función (myFunction) se declara cuando se crea la función. Esto significa que puede llamar a una función antes de que esté definida.

Ejemplo de declaración de función:
```JavaScript
function add (a, b) {
  return a + b;
};
```

## ¿Qué es una expresión de función?

Las expresiones de función ocurren cuando creas una función y la asignas a una variable. La función es anónima, lo que significa que no tiene nombre. Por ejemplo:
```JavaScript
let myFunction = function() {
  // we do something
};
```
Como puede ver, la función está asignada a la variable myFunction. Esto significa que debe definir una función antes de poder llamarla.

Ejemplo de expresión de función:
```JavaScript
let add = function (a, b) {
  return a + b;
};
```

## Diferencias entre una expresión de función y una declaración

Existen varias diferencias clave entre expresiones de función y declaraciones de función:

* Las declaraciones de funciones son elevadas, pero las expresiones de funciones no. Esto significa que puede llamar a una función antes de que esté definida, pero no puede hacerlo con una expresión de función.

* Con las expresiones de función, puede utilizar la función tan pronto como esté definida. Al declarar una función, debe esperar hasta que se haya analizado todo el script.

* Las expresiones de funciones se pueden utilizar como argumento para otra función, pero las declaraciones de funciones no.

* Las expresiones de funciones pueden ser anónimas, pero las declaraciones de funciones no.

## Comprender el alcance en una expresión de función: diferencias en el levantamiento de JavaScript

Al igual que con la declaración let, las declaraciones de funciones se generan encima del código principal.

Las expresiones de funciones no se elevan. Esto les permite mantener una copia de las variables locales del ámbito en el que fueron definidas.

Normalmente, puede utilizar declaraciones de funciones y expresiones de funciones indistintamente. Pero hay ocasiones en las que las expresiones de función dan como resultado un código más fácil de entender sin la necesidad de un nombre de función temporal.

## Cómo elegir entre una expresión y una declaración

Entonces, ¿cuándo debería utilizar expresiones de función y cuándo debería utilizar declaraciones de función?

La respuesta depende de tus necesidades. Si necesita una función más flexible o una función que no se eleve, entonces una expresión de función es el camino a seguir. Si necesita una función más legible y comprensible, utilice una declaración de función.

Como habrás notado, las dos sintaxis son similares. La diferencia más obvia es que las expresiones de funciones son anónimas, mientras que las declaraciones de funciones tienen nombre.

Normalmente se utiliza una declaración de función cuando se necesita algo que las expresiones de función no pueden hacer. Si no necesita hacer nada que solo se pueda hacer con una declaración de función, entonces es mejor usar una expresión de función.

Utilice declaraciones de funciones cuando necesite crear una función recursiva o cuando necesite llamar una función antes de definirla. Utilice expresiones de función para obtener un código más limpio cuando no necesite hacer ninguna de estas cosas.

## Beneficios de las declaraciones de funciones

Hay varios beneficios clave al declarar funciones.

* Esto puede hacer que el código sea más legible. Si tiene una función larga, darle un nombre puede ayudar a realizar un seguimiento de lo que hace.
* Las declaraciones de funciones se elevan, lo que significa que están disponibles antes de que se definan en su código. Esto ayuda si necesita utilizar una función antes de definirla.

## Beneficios de las expresiones de funciones

Las expresiones de funciones también tienen sus ventajas.

* Son más flexibles que las declaraciones de funciones. Puede crear expresiones de funciones y asignarlas a diferentes variables, lo que puede resultar útil cuando necesita utilizar la misma función en diferentes lugares.
* Las expresiones de función no se elevan, por lo que no puede usarlas antes de que estén definidas en su código. Esto ayuda si desea asegurarse de que una función solo se utilice después de haber sido definida.

## Cuándo elegir una declaración de función o expresión de función

En la mayoría de los casos, es fácil determinar qué método de definir una función es mejor para sus necesidades. Estas pautas le ayudarán a tomar una decisión rápida en la mayoría de las situaciones.

Utilice declaraciones de funciones cuando:

* necesita una función más legible y comprensible (por ejemplo, una función larga o una que necesitará usar en diferentes lugares);
* una función anónima no le conviene;
* necesitas crear una función recursiva;
* es necesario llamar a la función antes de definirla.

Utilice expresiones de función cuando:

* necesitas una función más flexible;
* necesitas una función que no se levante;
* una función sólo debe usarse cuando está definida;
* la función es anónima o no necesita nombre para su uso posterior;
* desea controlar cuándo se ejecuta una función utilizando técnicas como funciones invocadas inmediatamente (IIFE);
* desea pasar una función como argumento a otra función.

Sin embargo, hay varios casos en los que la flexibilidad de las expresiones de funciones se convierte en una poderosa ventaja.

***

# ¿Qué es la palabra clave "this" en JS?

this es una palabra clave en JavaScript que contiene el objeto (contexto) del código que se ejecuta.

Creo que es más fácil pensar que this es como una variable única que almacena el contexto del código que se ejecuta. Por el contrario, el contexto es el significado de palabra clave this.

this tiene diferentes significados dependiendo de dónde se use:

* Por sí solo, this se refiere al objeto global (window).
* En un método, this se refiere al objeto principal.
* En una función, this se refiere al objeto global.
* En la función en 'strict mode' - this = undefined.
* En una función de flecha, this se refiere al contexto donde se creó la función.
* En un evento, this se refiere al elemento que desencadenó el evento.

## ¿Qué es el contexto?

Cualquier definición de this gira de alguna manera en torno a la palabra contexto. 

JavaScript es un lenguaje de subproceso único, lo que significa que solo se puede ejecutar una tarea a la vez. El intérprete de JavaScript siempre comienza a ejecutar código desde el contexto global (en el navegador, este es el objeto window). De ahora en adelante, el contexto de la primera función llamada será un objeto global (window). Nuestra función puede crear un nuevo objeto, crear métodos en él y ejecutar uno de esos métodos, ahora el contexto de llamada ha cambiado para apuntar a un nuevo objeto que se creó a partir del contexto global.

Por lo tanto, el contexto es siempre algún objeto desde el cual se llamó al método (función).

A medida que se procesa el código, se crean otros objetos dentro del contexto global window; representan nuevos contextos en los que se ejecuta el código. Por tanto, se pueden mezclar muchos contextos en un código. Una función puede llamar a métodos de diferentes objetos y cada uno de ellos tendrá su propio contexto.

El contexto es siempre el valor de palabra clave this, que es una referencia al objeto que invocó el método (función). Un contexto es un objeto que "posee" el código ejecutable. Y this siempre se refiere al objeto (contexto) que lanzó la función.

## Métodos y funciones.

En el cuerpo de cada método o función, que esencialmente siempre es un método de algún objeto, podemos usar this para referirnos al objeto principal que llamó a la función, o en el que se encuentra el método. En pocas palabras, this es el objeto principal que llamó al método (función).

Por ejemplo, cuando this se usa dentro de la función my_function(), podemos decir que this es una variable universal cuyo valor es el objeto que llamó a la función my_function().

Esto es conveniente porque:
* Es inconveniente escribir el nombre del objeto principal en el código cada vez para llamar a su método (función), pero puedes escribir this.my_function() en lugar de window.my_object.my_function().
* A veces es posible que ni siquiera sepamos de antemano el objeto que llamó a la función. Porque el programador escribió el código de tal manera que el objeto (contexto) debe especificarse al llamar a la función (este enfoque le permite usar la misma función/método para diferentes objetos).

Pensar en this como una variable que hace referencia al objeto que llamó al método (función) hace que sea mucho más fácil usarlo en su código.

Es importante entender que this no depende de dónde se declaró la función, sino de cómo (quién) la llamó. El lugar donde se declara una función tiene que ver con su alcance, no con su contexto.

## Alcance (scope) y contexto

Además del contexto, también es necesario comprender qué es el alcance. Estos conceptos suelen confundirse. Llamándose unos a otros. Sin embargo, el contexto y el alcance son dos cosas diferentes.

Cada llamada a función tiene un alcance y un contexto asociados. El alcance se basa en dónde se llama la función (qué variables están disponibles para ella) y el contexto se basa en quién llama a la función (qué objeto). En otras palabras, el alcance se refiere al acceso de una función a las variables cuando se llama y es único para cada llamada. El contexto es siempre el valor de palabra clave this, que es una referencia al objeto que "posee" el código que se está ejecutando actualmente.

## this es el valor predeterminado

La mayoría de las veces this se usa dentro de una función/método. Sin embargo, this también funciona en el ámbito global.

Cuando escribimos una función simple y luego la usamos, algún objeto todavía la llama y esto se refiere a ese objeto que llama. Para el navegador, este es el objeto de window.

Ejecutemos este código en la consola del navegador:
```JavaScript
function get_this(){

	return this
}

get_this() // ▸ Window {0: Window, window: Window, self: Window, …}
this       // ▸ Window {0: Window, window: Window, self: Window, …}
```
Como podemos ver en ambos casos this será el objeto Window. Esto es equivalente a un código como este:
```JavaScript
window.get_this = function(){

	return this
}

window.get_this() // ▸ Window {0: Window, window: Window, self: Window, …}
window.this       // ▸ Window {0: Window, window: Window, self: Window, …}
```
Sin embargo, si la función se ejecuta en modo estricto, this escribirá en undefined, ya que los enlaces están deshabilitados de forma predeterminada en este modo:
```JavaScript
function get_this(){
	'use strict'

	return this
}

get_this()        // ▸ undefined
window.get_this() // ▸ Window {0: Window, window: Window, self: Window, …}
```

En modo estricto, debe indicar directamente el contexto desde el cual se llama al método:

## this en métodos

El método se llama visualmente: primero viene el nombre del objeto ourObject, luego un punto ., luego el nombre del método ourMethod.

this es muy fácil de rastrear cuando se llama a un método junto con un objeto object.method(); lo que esté en el lado izquierdo del punto estará en el this del método llamado (en este caso, this = objeto):
```JavaScript
let object = {

	 method: function(){

		console.log( this )
	}
}

object.method() // ▸ {method: ƒ}
```
Esta es la opción más fácil para entender lo que habrá en this. Aquí el método se llama desde el mismo objeto en el que está definido. Por lo tanto, this se refiere a una instancia de object porque ese objeto llama al methodo. this es el objeto que llama.

## this en la función constructora

Cuando se usa una función para crear nuevos objetos, se debe llamar usando la palabra clave new. Cuando se llama de esta manera, la función se llamará como constructor del nuevo objeto y se devolverá el nuevo objeto.

En este caso, el nombre de la función suele escribirse con mayúscula. Este nombre se convertirá en el nombre de la instancia del objeto.

Cuando se llama al constructor, this apunta al objeto recién creado, no al objeto que inició la construcción.
```JavaScript
function Doge( param ) {

	// this = {} - un nuevo objeto vacío que llamó a esta función gracias a new

	this.saying = param

	// return this // es un constructor, no puede devolver nada
}

new Doge( 'Hello' )  // ▸ Doge {saying: "Hello"}
new Doge( 'Browser' ) // ▸ Doge {saying: "Browser"}
```

Echemos un vistazo debajo del capó para comprender mejor por qué this funciona como lo hace en una función constructora. Cuando se llama a una función a través de new, la llamada a esta función ocurre de manera diferente:
1. Se crea un objeto vacío, cuyo nombre se toma del nombre de la función.
2. El objeto creado llama a la función como constructor. Dado que la función es llamada por un nuevo objeto, esto dentro de la función se refiere a este nuevo objeto.
3. La función constructora se ejecuta y new devuelve el objeto recién creado.

No es necesario utilizar return en dicha función; no tiene sentido hacerlo porque es un constructor de objetos. El trabajo de la función constructora es establecer las propiedades y métodos del nuevo objeto y no puede devolver nada.

## Hagámoslo más complicado: llamar a una función dentro de un constructor

¿Qué sucede si ponemos una función normal dentro de una función constructora y la llamamos allí?

Tenemos una función getThis() global, una función constructora y un nuevo objeto creado por la función constructora. En este ejemplo, el getthis() global se llama desde la función constructora:
```JavaScript
function get_this(){

	console.log( this )
}

function Doge( saying ){

	this.saying = saying

	get_this()
}

new Doge( 'No Window!' )

// lo veremos en la consola:
// ▸ Window {0: Window, window: Window, self: Window, …}
// ▸ Doge {saying: "No Window!"}
```

get_this() todavía apunta a Window porque aunque get_this() se llama dentro de la función constructora de Doge(), en realidad se llama desde el ámbito global: window.get_this().

¿Qué pasa si creamos un método dentro de un constructor y lo llamamos en el constructor al crear un nuevo objeto?
```JavaScript
function Doge( saying ){

	this.saying = saying

	this.get_this = function(){

		console.log( this )
	}

	this.get_this()
}

new Doge( 'no Window' )  // creemos una instancia Doge

// ▸ Doge {saying: "no Window", getThis: ƒ}
// ▸ Doge {saying: "no Window", getThis: ƒ}
```

get_this() todavía apunta al objeto recién creado. Porque él fue quien lo llamó.

¿Qué pasa si llamamos a Doge sin la palabra clave new?
```JavaScript
function Doge( saying ){

	this.saying = saying

	this.get_this = function(){

		console.log( this )
	}

	this.get_this()

	console.log( this )
}

Doge( 'Quién está ahí?' ) // ejecutar Doge como una función simple

// Nos metemos en la consola:
// ▸ Window {0: Window, window: Window, self: Window, …}
// ▸ Window {0: Window, window: Window, self: Window, …}
```
Como podemos ver, la función fue llamada por el objeto window y agregó una nueva propiedad saying y un método get_this() al objeto de llamado window. Asegurémonos de esto, observemos el valor de la propiedad saying y llamemos al método get_this().
```JavaScript
window.saying      // "¿Quién está ahí?"
window.get_this()  // Window {0: Window, window: Window, self: Window, …}
```

